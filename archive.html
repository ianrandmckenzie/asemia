<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Security Headers -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff" />
  <meta http-equiv="X-XSS-Protection" content="1; mode=block" />
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin" />
  <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=(), payment=()" />

  <meta name="description" content="Archived Typeforms - View saved typographic compositions in various sizes" />
  <meta name="keywords" content="typography, typeforms, letterforms, design, archive, serifs, bodies, joins" />
  <title>Typeform Archive - Typographic Tinkerer</title>
  <meta name="robots" content="index, follow">
  <meta name="language" content="en">

  <!-- Open Graph Meta Tags for Social Sharing -->
  <meta property="og:title" content="Typeform Archive - Typographic Tinkerer">
  <meta property="og:description" content="View archived typographic compositions in various responsive sizes">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://asemia.relentlesscurious.com/archive">

  <!-- Canonical URL -->
  <link rel="canonical" href="https://asemia.relentlesscurious.com/archive">

  <link href="/src/style.css" rel="stylesheet" />
</head>
<body class="bg-gray-50 dark:bg-slate-900 min-h-screen">
  <!-- Header -->
  <header class="bg-white dark:bg-slate-800 shadow-sm border-b border-gray-200 dark:border-slate-700">
    <div class="max-w-7xl mx-auto px-4 py-6">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-3xl font-bold text-gray-900 dark:text-gray-100">
            Typeform Archive
          </h1>
          <p class="text-gray-600 dark:text-gray-300 mt-2">
            Explore saved typographic compositions in various sizes
          </p>
        </div>
        <nav class="flex gap-4">
          <a href="/" class="text-blue-600 hover:text-blue-700 dark:text-blue-400 font-medium">
            ← Back to Builder
          </a>
        </nav>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="max-w-7xl mx-auto px-4 py-8">
    <!-- Loading State -->
    <div id="loading" class="text-center py-12">
      <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      <p class="mt-4 text-gray-600 dark:text-gray-300">Loading archived forms...</p>
    </div>

    <!-- Error State -->
    <div id="error" class="hidden text-center py-12">
      <div class="text-red-500 text-xl mb-4">⚠️</div>
      <p class="text-gray-600 dark:text-gray-300 mb-4">Failed to load archived forms</p>
      <p class="text-gray-500 dark:text-gray-400 text-sm">Check the browser console for more details</p>
    </div>

    <!-- Archive Grid -->
    <div id="archive-grid" class="hidden">
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8" id="archive-forms">
        <!-- Forms will be rendered here -->
      </div>
    </div>
  </main>

  <!-- Scripts -->
  <script>
    let rulesData = null;

    // Load rules data to get SVG strings
    async function loadRulesData() {
      if (rulesData) return rulesData;

      try {
        const response = await fetch('/assets/rules.json');
        rulesData = await response.json();
        return rulesData;
      } catch (error) {
        console.error('Failed to load rules.json:', error);
        return null;
      }
    }

    // Get SVG string and shape properties from rules data
    function getShapeData(category, angleKey, shapeName) {
      if (!rulesData?.shapes?.[category]?.[angleKey]) {
        console.warn(`SVG not found: ${category}/${angleKey}/${shapeName}`);
        return null;
      }

      const shapes = rulesData.shapes[category][angleKey];
      const shape = shapes.find(s => s.shape_name === shapeName);

      if (!shape) {
        console.warn(`Shape not found: ${shapeName} in ${category}/${angleKey}`);
        return null;
      }

      return {
        svg: shape.svg,
        width: shape.width || 1,
        height: shape.height || 1,
        orientation: shape.cell_orientation || 'center center'
      };
    }

    // Create a complete overlapped composition exactly like the builder
    function createOverlappedComposition(serifsData, joinsData, size = 'md') {
      const compositionContainer = document.createElement('div');
      compositionContainer.className = 'relative inline-block mx-auto';
      compositionContainer.style.overflow = 'visible'; // Allow shapes to overflow composition boundaries

      // Size scaling factors (all based on builder's 100px base cell size)
      const scaleFactors = {
        'xs': 0.25,    // 25px cells
        'sm': 0.4,     // 40px cells
        'md': 0.7,     // 70px cells
        'lg': 1.0,     // 100px cells (same as builder)
        'xl': 1.3,     // 130px cells
        '2xl': 1.6     // 160px cells
      };

      const scale = scaleFactors[size];
      const cellSize = 100 * scale;  // Base 100px cell scaled

      // Builder measurements scaled proportionally
      const serifsSize = 500 * scale;  // 5 × 100px cells
      const joinsSize = 400 * scale;   // 4 × 100px cells
      const offset = 50 * scale;       // 50px offset scaled

      // Create serifs grid (5x5, on top)
      if (serifsData && serifsData.shapes.length > 0) {
        const serifsGrid = createBuilderGrid(serifsData, serifsSize, 5, cellSize);
        serifsGrid.className += ' relative z-10';
        compositionContainer.appendChild(serifsGrid);
      }

      // Create joins grid (4x4, positioned absolutely behind and inset)
      if (joinsData && joinsData.shapes.length > 0) {
        const joinsGrid = createBuilderGrid(joinsData, joinsSize, 4, cellSize);
        joinsGrid.className += ` absolute z-0`;
        joinsGrid.style.top = `${offset}px`;
        joinsGrid.style.left = `${offset}px`;
        compositionContainer.appendChild(joinsGrid);
      }

      return compositionContainer;
    }

    // Create a grid that exactly matches the builder's structure and positioning
    function createBuilderGrid(gridData, gridSize, cols, cellSize) {
      const gridContainer = document.createElement('div');
      
      gridContainer.className = `grid grid-cols-${cols} gap-0`;  // Exact same as builder
      gridContainer.style.width = `${gridSize}px`;
      gridContainer.style.height = `${gridSize}px`;
      gridContainer.style.overflow = 'visible'; // Allow shapes to overflow grid boundaries      // Create all cells exactly like the builder
      const totalCells = cols * cols;
      const cellElements = [];

      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement('div');
        cell.className = 'relative'; // Same as builder: 'w-[100px] h-[100px] relative' but using dynamic sizing
        cell.style.width = `${cellSize}px`;
        cell.style.height = `${cellSize}px`;
        gridContainer.appendChild(cell);
        cellElements.push(cell);
      }

      // Place shapes using the same logic as the builder
      gridData.shapes.forEach(shapeInfo => {
        const cellIndex = shapeInfo.index;
        const shapeData = getShapeData(shapeInfo.category, shapeInfo.angleKey, shapeInfo.shapeName);

        if (!shapeData) {
          console.warn(`Could not load shape data for ${shapeInfo.category}/${shapeInfo.angleKey}/${shapeInfo.shapeName}`);
          return;
        }

        const { svg, width, height } = shapeData;
        const cell = cellElements[cellIndex];

        if (!cell) return;

        // Create shape element exactly like the builder does
        const shapeElement = document.createElement('div');
        shapeElement.className = 'absolute'; // Remove inset-0 to allow overflow positioning
        
        // Add SVG content
        shapeElement.innerHTML = svg;
        
        // Style the SVG to allow overflow like the builder
        const svgElement = shapeElement.querySelector('svg');
        if (svgElement) {
          svgElement.classList.add('text-gray-900', 'dark:text-gray-100');
          // Remove size constraints to allow overflow - let SVG use its natural dimensions
          // The SVG viewBox and builder's percentage positioning will handle sizing
        }        // Handle multi-cell shapes by spanning across cells
        if (width > 1 || height > 1) {
          // Calculate position for multi-cell shape
          const row = Math.floor(cellIndex / cols);
          const col = cellIndex % cols;

          // Position relative to the grid, not the cell
          shapeElement.style.position = 'absolute';
          shapeElement.style.left = `${col * cellSize}px`;
          shapeElement.style.top = `${row * cellSize}px`;
          shapeElement.style.width = `${width * cellSize}px`;
          shapeElement.style.height = `${height * cellSize}px`;
          shapeElement.style.zIndex = '10';

          // Add to grid container instead of cell
          gridContainer.appendChild(shapeElement);
        } else {
          // Single cell shape - add to the cell
          cell.appendChild(shapeElement);
        }
      });

      return gridContainer;
    }

    // Create a single grid (either serifs or joins) with proper multi-cell support
    function createSingleGrid(gridData, gridSize, cols) {
      const gridContainer = document.createElement('div');
      const cellSize = gridSize / cols;

      gridContainer.className = `grid grid-cols-${cols} gap-0`;  // No background colors
      gridContainer.style.width = `${gridSize}px`;
      gridContainer.style.height = `${gridSize}px`;

      // Create all cells for the complete grid
      const totalCells = cols * cols;
      const cellElements = [];

      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement('div');
        cell.className = 'flex items-center justify-center relative'; // No borders for clean positioning
        cell.style.width = `${cellSize}px`;
        cell.style.height = `${cellSize}px`;
        gridContainer.appendChild(cell);
        cellElements.push(cell);
      }

      // Track which cells are occupied by multi-cell shapes
      const occupiedCells = new Set();

      // Fill in the shapes to show the complete composition
      gridData.shapes.forEach(shapeInfo => {
        const cellIndex = shapeInfo.index;
        const shapeData = getShapeData(shapeInfo.category, shapeInfo.angleKey, shapeInfo.shapeName);

        if (!shapeData) {
          console.warn(`Could not load shape data for ${shapeInfo.category}/${shapeInfo.angleKey}/${shapeInfo.shapeName}`);
          return;
        }

        const { svg, width, height } = shapeData;

        // Calculate which cells this shape should occupy
        const row = Math.floor(cellIndex / cols);
        const col = cellIndex % cols;

        // Check if this is a multi-cell shape
        if (width > 1 || height > 1) {
          // Multi-cell shape - create a container that spans multiple cells
          const shapeContainer = document.createElement('div');
          shapeContainer.className = 'absolute flex items-center justify-center';
          shapeContainer.style.width = `${cellSize * width}px`;
          shapeContainer.style.height = `${cellSize * height}px`;
          shapeContainer.style.left = `${col * cellSize}px`;
          shapeContainer.style.top = `${row * cellSize}px`;
          shapeContainer.style.zIndex = '10';

          // Create SVG container
          const svgContainer = document.createElement('div');
          svgContainer.className = 'w-full h-full flex items-center justify-center';
          svgContainer.innerHTML = svg;

          // Style the SVG
          const svgElement = svgContainer.querySelector('svg');
          if (svgElement) {
            svgElement.classList.add('w-full', 'h-full', 'text-gray-900', 'dark:text-gray-100');
            svgElement.style.maxWidth = '100%';
            svgElement.style.maxHeight = '100%';
          }

          shapeContainer.appendChild(svgContainer);
          gridContainer.appendChild(shapeContainer);

          // Mark all cells occupied by this shape
          for (let r = row; r < row + height && r < cols; r++) {
            for (let c = col; c < col + width && c < cols; c++) {
              occupiedCells.add(r * cols + c);
            }
          }
        } else {
          // Single-cell shape
          const cell = cellElements[cellIndex];
          if (cell && !occupiedCells.has(cellIndex)) {
            // Create SVG container
            const svgContainer = document.createElement('div');
            svgContainer.className = 'w-full h-full flex items-center justify-center';
            svgContainer.innerHTML = svg;

            // Style the SVG
            const svgElement = svgContainer.querySelector('svg');
            if (svgElement) {
              svgElement.classList.add('w-full', 'h-full', 'text-gray-900', 'dark:text-gray-100');
              svgElement.style.maxWidth = '100%';
              svgElement.style.maxHeight = '100%';
            }

            cell.appendChild(svgContainer);
            occupiedCells.add(cellIndex);
          }
        }
      });

      return gridContainer;
    }

    // Create size controls
    function createSizeControls(formName, currentSize, onSizeChange) {
      const sizes = [
        { key: 'xs', label: 'XS' },
        { key: 'sm', label: 'SM' },
        { key: 'md', label: 'MD' },
        { key: 'lg', label: 'LG' },
        { key: 'xl', label: 'XL' },
        { key: '2xl', label: '2XL' }
      ];

      const container = document.createElement('div');
      container.className = 'flex gap-2 justify-center';

      sizes.forEach(size => {
        const button = document.createElement('button');
        button.textContent = size.label;
        button.className = `px-3 py-1 text-sm rounded transition-colors ${
          size.key === currentSize
            ? 'bg-blue-600 text-white'
            : 'bg-gray-200 dark:bg-slate-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-slate-600'
        }`;
        button.onclick = () => onSizeChange(size.key);
        container.appendChild(button);
      });

      return container;
    }

    // Render a single form showing the complete overlapped composition
    function renderForm(formData) {
      const formCard = document.createElement('div');
      formCard.className = 'bg-white dark:bg-slate-800 dark:border dark:border-slate-600 rounded-xl shadow-lg hover:-translate-y-0.5 hover:shadow-xl transition-all duration-200 overflow-hidden p-6';

      // Form header
      const header = document.createElement('div');
      header.className = 'text-center mb-6';

      const title = document.createElement('h2');
      title.textContent = formData.metadata.name || 'Untitled';
      title.className = 'text-2xl font-bold text-gray-900 dark:text-gray-100 mb-2';

      const meta = document.createElement('p');
      const createdDate = new Date(formData.metadata.created).toLocaleDateString();
      meta.textContent = `Created: ${createdDate}`;
      meta.className = 'text-gray-600 dark:text-gray-400 text-sm';

      header.appendChild(title);
      header.appendChild(meta);

      // Size controls
      let currentSize = 'md';
      const sizeControls = createSizeControls(formData.metadata.name, currentSize, (newSize) => {
        currentSize = newSize;
        updateComposition();
      });

      // Main composition container
      const compositionContainer = document.createElement('div');
      compositionContainer.className = 'flex justify-center mt-6';

      function updateComposition() {
        compositionContainer.innerHTML = '';

        // Create overlapped composition like the builder
        const hasSerifs = formData.grids.serifs && formData.grids.serifs.shapes.length > 0;
        const hasJoins = formData.grids.joins && formData.grids.joins.shapes.length > 0;

        if (hasSerifs || hasJoins) {
          const overlappedComposition = createOverlappedComposition(
            hasSerifs ? formData.grids.serifs : null,
            hasJoins ? formData.grids.joins : null,
            currentSize
          );

          const compositionWrapper = document.createElement('div');
          compositionWrapper.className = 'text-center';

          const compositionTitle = document.createElement('h3');
          compositionTitle.textContent = 'Typeform Composition';
          compositionTitle.className = 'text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4';

          compositionWrapper.appendChild(compositionTitle);
          compositionWrapper.appendChild(overlappedComposition);
          compositionContainer.appendChild(compositionWrapper);
        } else {
          // If no shapes in either grid, show a message
          const emptyMessage = document.createElement('p');
          emptyMessage.textContent = 'This composition appears to be empty.';
          emptyMessage.className = 'text-gray-500 dark:text-gray-400 text-center italic py-8';
          compositionContainer.appendChild(emptyMessage);
        }
      }

      // Initial render
      updateComposition();

      // Assemble the card
      formCard.appendChild(header);
      formCard.appendChild(sizeControls);
      formCard.appendChild(compositionContainer);

      return formCard;
    }

    // Load and display all archived forms
    async function loadArchivedForms() {
      const loadingEl = document.getElementById('loading');
      const errorEl = document.getElementById('error');
      const gridEl = document.getElementById('archive-grid');

      try {
        console.log('Loading rules data...');

        // Load rules data first (required for SVG rendering)
        await loadRulesData();
        if (!rulesData) {
          throw new Error('Failed to load rules data');
        }
        console.log('Rules data loaded successfully');

        console.log('Loading archived forms...');

        // Load all archived forms
        const archiveFiles = ['apek.json', 'cam.json', 'cam_v2.json'];
        const forms = [];

        for (const filename of archiveFiles) {
          try {
            console.log(`Fetching ${filename}...`);
            const response = await fetch(`/archive/${filename}`);
            if (response.ok) {
              const formData = await response.json();
              console.log(`Loaded ${filename}:`, formData.metadata?.name);
              forms.push(formData);
            } else {
              console.warn(`Failed to fetch ${filename}: ${response.status}`);
            }
          } catch (error) {
            console.warn(`Failed to load ${filename}:`, error);
          }
        }

        console.log(`Loaded ${forms.length} forms total`);

        if (forms.length === 0) {
          throw new Error('No forms found');
        }

        // Hide loading, show grid
        loadingEl.classList.add('hidden');
        gridEl.classList.remove('hidden');

        const formsContainer = document.getElementById('archive-forms');

        // Render each form as a complete composition
        forms.forEach(formData => {
          console.log('Rendering form composition:', formData.metadata?.name);
          const formElement = renderForm(formData);
          formsContainer.appendChild(formElement);
        });

        console.log('Archive loaded successfully!');

      } catch (error) {
        console.error('Failed to load archived forms:', error);
        loadingEl.classList.add('hidden');
        errorEl.classList.remove('hidden');
      }
    }

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', loadArchivedForms);
  </script>
</body>
</html>
