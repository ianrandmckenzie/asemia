<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Security Headers -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff" />
  <meta http-equiv="X-XSS-Protection" content="1; mode=block" />
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin" />
  <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=(), payment=()" />

  <meta name="description" content="Archived Typeforms - View saved typographic compositions in various sizes" />
  <meta name="keywords" content="typography, typeforms, letterforms, design, archive, serifs, bodies, joins" />
  <title>Typeform Archive - Typographic Tinkerer</title>
  <meta name="robots" content="index, follow">
  <meta name="language" content="en">

  <!-- Open Graph Meta Tags for Social Sharing -->
  <meta property="og:title" content="Typeform Archive - Typographic Tinkerer">
  <meta property="og:description" content="View archived typographic compositions in various responsive sizes">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://asemia.relentlesscurious.com/archive">

  <!-- Canonical URL -->
  <link rel="canonical" href="https://asemia.relentlesscurious.com/archive">

  <link href="/src/style.css" rel="stylesheet" />
</head>
<body class="bg-gray-50 dark:bg-slate-900 min-h-screen">
  <!-- Header -->
  <header class="bg-white dark:bg-slate-800 shadow-sm border-b border-gray-200 dark:border-slate-700">
    <div class="max-w-7xl mx-auto px-4 py-6">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-3xl font-bold text-gray-900 dark:text-gray-100">
            Typeform Archive
          </h1>
          <p class="text-gray-600 dark:text-gray-300 mt-2">
            Explore saved typographic compositions in various sizes
          </p>
        </div>
        <nav class="flex gap-4">
          <a href="/" class="text-blue-600 hover:text-blue-700 dark:text-blue-400 font-medium">
            ← Back to Builder
          </a>
        </nav>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="max-w-7xl mx-auto px-4 py-8">
    <!-- Loading State -->
    <div id="loading" class="text-center py-12">
      <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      <p class="mt-4 text-gray-600 dark:text-gray-300">Loading archived forms...</p>
    </div>

    <!-- Error State -->
    <div id="error" class="hidden text-center py-12">
      <div class="text-red-500 text-xl mb-4">⚠️</div>
      <p class="text-gray-600 dark:text-gray-300 mb-4">Failed to load archived forms</p>
      <p class="text-gray-500 dark:text-gray-400 text-sm">Check the browser console for more details</p>
    </div>

    <!-- Archive Grid -->
    <div id="archive-grid" class="hidden">
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8" id="archive-forms">
        <!-- Forms will be rendered here -->
      </div>
    </div>
  </main>

  <!-- Scripts -->
  <script>
    let rulesData = null;

    // Load rules data to get SVG strings
    async function loadRulesData() {
      if (rulesData) return rulesData;

      try {
        const response = await fetch('/assets/rules.json');
        rulesData = await response.json();
        return rulesData;
      } catch (error) {
        console.error('Failed to load rules.json:', error);
        return null;
      }
    }

    // Get SVG string from rules data
    function getSVGByPath(category, angleKey, shapeName) {
      if (!rulesData?.shapes?.[category]?.[angleKey]) {
        console.warn(`SVG not found: ${category}/${angleKey}/${shapeName}`);
        return null;
      }

      const shapes = rulesData.shapes[category][angleKey];
      const shape = shapes.find(s => s.shape_name === shapeName);

      if (!shape) {
        console.warn(`Shape not found: ${shapeName} in ${category}/${angleKey}`);
        return null;
      }

      return shape.svg;
    }

    // Create a grid for a form that displays the complete composition
    function createFormGrid(gridData, size = 'md') {
      const gridContainer = document.createElement('div');
      
      // Size-specific cell classes
      const sizeClasses = {
        'xs': 'w-6 h-6',    // Smaller for overview
        'sm': 'w-8 h-8', 
        'md': 'w-12 h-12',  // Good default size
        'lg': 'w-16 h-16',
        'xl': 'w-20 h-20',
        '2xl': 'w-24 h-24'  // Large for detail
      };
      
      // Grid layout classes
      const gridCols = gridData.gridType === 'serifs' ? 'grid-cols-5' : 'grid-cols-4';
      const totalCells = gridData.gridType === 'serifs' ? 25 : 16;
      
      gridContainer.className = `grid ${gridCols} gap-px border-2 border-gray-300 dark:border-slate-600 bg-gray-300 dark:bg-slate-600 p-2 rounded-lg max-w-fit mx-auto`;

      // Create all cells for the complete grid
      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement('div');
        cell.className = `${sizeClasses[size]} bg-white dark:bg-slate-800 flex items-center justify-center relative overflow-hidden`;
        gridContainer.appendChild(cell);
      }

      // Fill in the shapes to show the complete composition
      gridData.shapes.forEach(shapeInfo => {
        const cell = gridContainer.children[shapeInfo.index];
        if (cell) {
          const svgString = getSVGByPath(shapeInfo.category, shapeInfo.angleKey, shapeInfo.shapeName);
          if (svgString) {
            // Create a container for the SVG
            const svgContainer = document.createElement('div');
            svgContainer.className = 'w-full h-full flex items-center justify-center';
            svgContainer.innerHTML = svgString;
            
            // Style the SVG to fit the cell
            const svg = svgContainer.querySelector('svg');
            if (svg) {
              svg.classList.add('w-full', 'h-full', 'text-gray-900', 'dark:text-gray-100');
              svg.style.maxWidth = '100%';
              svg.style.maxHeight = '100%';
            }
            
            cell.appendChild(svgContainer);
          } else {
            console.warn(`Could not load SVG for ${shapeInfo.category}/${shapeInfo.angleKey}/${shapeInfo.shapeName}`);
          }
        }
      });

      return gridContainer;
    }

    // Create size controls
    function createSizeControls(formName, currentSize, onSizeChange) {
      const sizes = [
        { key: 'xs', label: 'XS' },
        { key: 'sm', label: 'SM' },
        { key: 'md', label: 'MD' },
        { key: 'lg', label: 'LG' },
        { key: 'xl', label: 'XL' },
        { key: '2xl', label: '2XL' }
      ];

      const container = document.createElement('div');
      container.className = 'flex gap-2 justify-center';

      sizes.forEach(size => {
        const button = document.createElement('button');
        button.textContent = size.label;
        button.className = `px-3 py-1 text-sm rounded transition-colors ${
          size.key === currentSize
            ? 'bg-blue-600 text-white'
            : 'bg-gray-200 dark:bg-slate-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-slate-600'
        }`;
        button.onclick = () => onSizeChange(size.key);
        container.appendChild(button);
      });

      return container;
    }

    // Render a single form showing the complete composition
    function renderForm(formData) {
      const formCard = document.createElement('div');
      formCard.className = 'bg-white dark:bg-slate-800 dark:border dark:border-slate-600 rounded-xl shadow-lg hover:-translate-y-0.5 hover:shadow-xl transition-all duration-200 overflow-hidden p-6';

      // Form header
      const header = document.createElement('div');
      header.className = 'text-center mb-6';

      const title = document.createElement('h2');
      title.textContent = formData.metadata.name || 'Untitled';
      title.className = 'text-2xl font-bold text-gray-900 dark:text-gray-100 mb-2';

      const meta = document.createElement('p');
      const createdDate = new Date(formData.metadata.created).toLocaleDateString();
      meta.textContent = `Created: ${createdDate}`;
      meta.className = 'text-gray-600 dark:text-gray-400 text-sm';

      header.appendChild(title);
      header.appendChild(meta);

      // Size controls
      let currentSize = 'md';
      const sizeControls = createSizeControls(formData.metadata.name, currentSize, (newSize) => {
        currentSize = newSize;
        updateComposition();
      });

      // Main composition container
      const compositionContainer = document.createElement('div');
      compositionContainer.className = 'space-y-6 mt-6';

      function updateComposition() {
        compositionContainer.innerHTML = '';

        // Show grids that have shapes
        if (formData.grids.serifs && formData.grids.serifs.shapes.length > 0) {
          const serifsSection = document.createElement('div');
          serifsSection.className = 'text-center';
          
          const serifsTitle = document.createElement('h3');
          serifsTitle.textContent = 'Serifs Grid';
          serifsTitle.className = 'text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3';
          
          const serifsGrid = createFormGrid(formData.grids.serifs, currentSize);
          
          serifsSection.appendChild(serifsTitle);
          serifsSection.appendChild(serifsGrid);
          compositionContainer.appendChild(serifsSection);
        }

        if (formData.grids.joins && formData.grids.joins.shapes.length > 0) {
          const joinsSection = document.createElement('div');
          joinsSection.className = 'text-center';
          
          const joinsTitle = document.createElement('h3');
          joinsTitle.textContent = 'Joins Grid';
          joinsTitle.className = 'text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3';
          
          const joinsGrid = createFormGrid(formData.grids.joins, currentSize);
          
          joinsSection.appendChild(joinsTitle);
          joinsSection.appendChild(joinsGrid);
          compositionContainer.appendChild(joinsSection);
        }

        // If no shapes in either grid, show a message
        if ((!formData.grids.serifs || formData.grids.serifs.shapes.length === 0) && 
            (!formData.grids.joins || formData.grids.joins.shapes.length === 0)) {
          const emptyMessage = document.createElement('p');
          emptyMessage.textContent = 'This composition appears to be empty.';
          emptyMessage.className = 'text-gray-500 dark:text-gray-400 text-center italic';
          compositionContainer.appendChild(emptyMessage);
        }
      }

      // Initial render
      updateComposition();

      // Assemble the card
      formCard.appendChild(header);
      formCard.appendChild(sizeControls);
      formCard.appendChild(compositionContainer);

      return formCard;
    }

    // Load and display all archived forms
    async function loadArchivedForms() {
      const loadingEl = document.getElementById('loading');
      const errorEl = document.getElementById('error');
      const gridEl = document.getElementById('archive-grid');

      try {
        console.log('Loading rules data...');
        
        // Load rules data first (required for SVG rendering)
        await loadRulesData();
        if (!rulesData) {
          throw new Error('Failed to load rules data');
        }
        console.log('Rules data loaded successfully');

        console.log('Loading archived forms...');

        // Load all archived forms
        const archiveFiles = ['apek.json', 'cam.json', 'cam_v2.json'];
        const forms = [];

        for (const filename of archiveFiles) {
          try {
            console.log(`Fetching ${filename}...`);
            const response = await fetch(`/archive/${filename}`);
            if (response.ok) {
              const formData = await response.json();
              console.log(`Loaded ${filename}:`, formData.metadata?.name);
              forms.push(formData);
            } else {
              console.warn(`Failed to fetch ${filename}: ${response.status}`);
            }
          } catch (error) {
            console.warn(`Failed to load ${filename}:`, error);
          }
        }

        console.log(`Loaded ${forms.length} forms total`);

        if (forms.length === 0) {
          throw new Error('No forms found');
        }

        // Hide loading, show grid
        loadingEl.classList.add('hidden');
        gridEl.classList.remove('hidden');

        const formsContainer = document.getElementById('archive-forms');

        // Render each form as a complete composition
        forms.forEach(formData => {
          console.log('Rendering form composition:', formData.metadata?.name);
          const formElement = renderForm(formData);
          formsContainer.appendChild(formElement);
        });

        console.log('Archive loaded successfully!');

      } catch (error) {
        console.error('Failed to load archived forms:', error);
        loadingEl.classList.add('hidden');
        errorEl.classList.remove('hidden');
      }
    }

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', loadArchivedForms);
  </script>
</body>
</html>
